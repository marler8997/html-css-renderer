#!/usr/bin/env python3
import os
import sys
import fcntl
import shutil
import subprocess
import multiprocessing
import re
import glob
import errno

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.dirname(SCRIPT_DIR)
ZIG_OUT_BIN = os.path.join(SCRIPT_DIR, "zig-out", "bin")
FSVEIL = os.path.join(ZIG_OUT_BIN, "fsveil")
TOOLS_DIR = os.path.join(SCRIPT_DIR, "tools")
DOWNLOADS_DIR = os.path.join(SCRIPT_DIR, "downloads")

global_quiet_mode = False

def log(*args, **kwargs):
    global global_quiet_mode
    if global_quiet_mode:
        return
    print(*args, file=sys.stderr, **kwargs)

def run(*args, **kwargs):
    if not 'check' in kwargs:
        kwargs['check'] = True
    log("[RUN] " + subprocess.list2cmdline(*args))
    sys.stdout.flush()
    return subprocess.run(*args, **kwargs)

def download(url, filename):
    makedirs(os.path.dirname(filename))
    tmp_filename = filename + ".downloading"
    remove(tmp_filename)
    if shutil.which("wget"):
        run(["wget", url, "--output-document", tmp_filename])
    else:
        run(["curl", url, "--output", tmp_filename])
    os.rename(tmp_filename, filename)

def symlink_force(to, frm):
    try:
        os.symlink(to, frm)
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(frm)
            os.symlink(to, frm)
        else:
            raise e

def makedirs(path):
    if not os.path.exists(path):
        os.makedirs(path)

def rmtree(path):
    if os.path.exists(path):
        shutil.rmtree(path)

def remove(path):
    try:
        os.remove(path)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise e

def install_archive(pkg_url):
    archive_basename = os.path.basename(pkg_url)
    installed_file = os.path.join(TOOLS_DIR, "installed", archive_basename)
    if not os.path.exists(installed_file):
        log("installing '{}'...".format(archive_basename))
        makedirs(DOWNLOADS_DIR)

        archive_file = os.path.join(DOWNLOADS_DIR, archive_basename)
        if not os.path.exists(archive_file):
            download(pkg_url, archive_file)
        if archive_file.endswith(".deb"):
            extract_dir = os.path.join(TOOLS_DIR, archive_basename + ".extracting")
            rmtree(extract_dir)
            makedirs(extract_dir)
            run(["ar", "x", archive_file], cwd=extract_dir)
            install_dir = os.path.join(TOOLS_DIR, archive_basename[:-4])
            makedirs(install_dir)
            run(["tar", "-C", install_dir, "-xf", os.path.join(extract_dir, "data.tar.zst")])
            rmtree(extract_dir)
        else:
            makedirs(TOOLS_DIR)
            run(["tar", "-C", TOOLS_DIR, "-xf", archive_file])
        makedirs(os.path.dirname(installed_file))
        run(['touch', installed_file])

#ZIG_BASENAME = "zig-linux-x86_64-0.10.0-dev.2674+d980c6a38"
ZIG_RELEASE_VERSION = "0.10.0"
ZIG_BASENAME = f"zig-linux-x86_64-{ZIG_RELEASE_VERSION}"

CMAKE_VERSION = "3.25.0"

PKG_URLS = [
    "http://s.minos.io/archive/bifrost/x86_64/coreutils-7.6-5.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/bash-4.4-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/findutils-4.4.2-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/git-2.10.2-1.tar.xz",
    #"http://s.minos.io/archive/bifrost/x86_64/make-3.81-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/sed-4.2.1-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/grep-2.6.3-2.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/tar-1.23-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/gzip-1.4-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/sysvinit-2.86-1.tar.xz",
    "http://s.minos.io/archive/bifrost/x86_64/perl-5.10.1-3.tar.xz",

    # curently used to provide libraries for cmake
    "http://mirrors.kernel.org/ubuntu/pool/main/g/glibc/libc6-amd64_2.35-0ubuntu3_i386.deb",
    f"https://github.com/Kitware/CMake/releases/download/v{CMAKE_VERSION}/cmake-{CMAKE_VERSION}-linux-x86_64.tar.gz",

    "https://github.com/NixOS/patchelf/releases/download/0.14.5/patchelf-0.14.5-x86_64.tar.gz",

    "https://github.com/marler8997/static-binaries/releases/download/v0.0/python-3.9.13.tar.xz",
    "https://github.com/marler8997/static-binaries/releases/download/v0.0/ninja-1.11.0.tar.xz",

    #"https://ziglang.org/builds/{}.tar.xz".format(ZIG_BASENAME),
    f"https://ziglang.org/download/{ZIG_RELEASE_VERSION}/zig-linux-x86_64-{ZIG_RELEASE_VERSION}.tar.xz",
]

LIBC_SRC = os.path.join(TOOLS_DIR, "libc6-amd64_2.35-0ubuntu3_i386/lib64")
TOOLS_LIB_PATCHED = os.path.join(TOOLS_DIR, "lib-patched")
LD_BASENAME = "ld-linux-x86-64.so.2"
LD = os.path.join(LIBC_SRC, LD_BASENAME)

def patchLib(patchelf, patched, lib_basename):
    print(f"patchLib '{lib_basename}'")
    if lib_basename in patched:
        log(f"library '{lib_basename}' already patched")
        return
    patched.add(lib_basename)
    if '/' in lib_basename:
        sys.exit(f"needed libs with slashes in them not implemented, i.e. '{lib_basename}'")
    if lib_basename == LD_BASENAME:
        return
    lib_dst = os.path.join(TOOLS_LIB_PATCHED, lib_basename)
    if os.path.exists(lib_dst):
        return
    lib_src = os.path.join(LIBC_SRC, lib_basename)
    if not os.path.exists(lib_src):
        sys.exit(f"missing library '{lib_src}'")
    patchNeededFor(patchelf, patched, lib_src)
    makedirs(TOOLS_LIB_PATCHED)
    tmp_dst = lib_dst + ".tmp"
    shutil.copy2(lib_src, tmp_dst)
    run([patchelf, "--set-rpath", TOOLS_LIB_PATCHED, tmp_dst])
    os.rename(tmp_dst, lib_dst)

def patchNeededFor(patchelf, patched, elf):
    result = run([patchelf, "--print-needed", elf], capture_output=True)
    if result.stderr:
        log(result.stderr)
    for line_bytes in result.stdout.splitlines():
        lib_basename = line_bytes.decode("utf8")
        patchLib(patchelf, patched, lib_basename)

def patchDynamicExe(patchelf, patched_libs, exe):
    patched_marker = exe + ".patched"
    if os.path.exists(patched_marker):
        log(f"{exe} already patched")

    # todo check if exe is already patched
    patchNeededFor(patchelf, patched_libs, exe)
    run([patchelf,
         "--set-interpreter", LD,
         "--set-rpath", TOOLS_LIB_PATCHED,
         exe])
    run(['touch', patched_marker])

def main():
    global global_quiet_mode
    if len(sys.argv) >= 2 and sys.argv[1] == "--quiet-fsveil-env":
        global_quiet_mode = True
        sys.argv = [sys.argv[0]] + sys.argv[2:]

    for pkg_url in PKG_URLS:
        install_archive(pkg_url)

    patchelf = os.path.join(TOOLS_DIR, "bin", "patchelf")
    patched_libs = set()

    cmake_tools_rel_path = f"cmake-{CMAKE_VERSION}-linux-x86_64/bin/cmake"
    cmake_bin = os.path.join(TOOLS_DIR, cmake_tools_rel_path)
    patchDynamicExe(patchelf, patched_libs, cmake_bin)
    symlink_force("../" + cmake_tools_rel_path, os.path.join(TOOLS_DIR, "bin/cmake"))

    zig_path = os.path.join(TOOLS_DIR, "bin/zig")
    symlink_force("../{}/zig".format(ZIG_BASENAME), zig_path)
    run([zig_path, "build", "buildtools"], cwd=SCRIPT_DIR)

    usr_bin_path = os.path.join(TOOLS_DIR, "usr", "bin")
    makedirs(usr_bin_path)
    shutil.copy2(os.path.join(SCRIPT_DIR, "zig-out/bin/which"), os.path.join(usr_bin_path, "which"))
    usr_bin_env_path = os.path.join(usr_bin_path, "env")
    symlink_force("../../bin/env", usr_bin_env_path)
    symlink_force("bash", os.path.join(TOOLS_DIR, "bin", "sh"))

    os.environ["IN_FSVEIL"] = "1"
    home_dirs = [
        #os.path.join(os.environ["HOME"], ".config"),
        #os.path.join(os.environ["HOME"], ".local"),
        os.path.join(os.environ["HOME"], ".cache"),
    ]
    for home_dir in home_dirs:
        makedirs(home_dir)
    veil_paths = [
        os.path.join(TOOLS_DIR, "opt/python/bin"),
        os.path.join(TOOLS_DIR, "usr/bin"),
        os.path.join(TOOLS_DIR, "bin"),
    ]
    os.environ["PATH"] = ":".join(veil_paths)
    log("PATH={}".format(os.environ["PATH"]))

    forward_args = sys.argv[1:]
    if len(forward_args) == 0:
        forward_args = ['sh']
    if forward_args[0].find("/") == -1:
        resolved = shutil.which(forward_args[0])
        if not resolved:
            sys.exit("program '{}' not found in PATH '{}'".format(forward_args[0], os.environ["PATH"]))
        forward_args[0] = resolved

    argv = [
        FSVEIL,
        "--link", os.path.join(TOOLS_DIR, "bin", "sh"), "/bin/sh",
        "--link", os.path.join(TOOLS_DIR, "usr", "bin", "env"), "/usr/bin/env",
        "/dev",
        "/proc",
        "/sys",
        "/tmp",
        "/etc/passwd",
    ] + home_dirs + [
        os.path.dirname(SCRIPT_DIR),
        #"--keep-rw",
        "--",
    ] + forward_args
    log(" ".join(argv))
    os.execve(argv[0], argv, os.environ)

main()
